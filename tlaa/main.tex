\documentclass{easychair}

\usepackage{doc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage{amssymb,color,relsize}
\definecolor{keywordcolor}{rgb}{0.7, 0.1, 0.1}   % red
\definecolor{tacticcolor}{rgb}{0.1, 0.2, 0.6}    % blue
\definecolor{commentcolor}{rgb}{0.4, 0.4, 0.4}   % grey
\definecolor{symbolcolor}{rgb}{0.0, 0.1, 0.6}    % blue
\definecolor{sortcolor}{rgb}{0.1, 0.5, 0.1}      % green
\definecolor{attributecolor}{rgb}{0.7, 0.1, 0.1} % red


\newcommand{\Con}{\mathsf{Con}}
\newcommand{\Ty}{\mathsf{Ty}}
\newcommand{\UU}{\mathcal{U}}

\usepackage{listings}
\def\lstlanguagefiles{lstlean.tex}
%% \lstset{language=lean}

\lstset{language=lean,breakatwhitespace,xleftmargin=\parindent}
\lstMakeShortInline"

\authorrunning{Altenkirch, Kaposi, Kovács, and von Raumer}
\titlerunning{Translation from Inductive-Inductive Types to Inductive Families}

\title{A Formal Translation from Inductive-Inductive Types to Inductive Families}

\author{
   Thorsten Altenkirch\inst{1}
\and
   Ambrus Kaposi\inst{2}
\and
   Andr\'as Kov\'acs\inst{2}
\and
   Jakob von Raumer\inst{1}
}

\institute{
   University of Nottingham, United Kingdom\\
   \email{thorsten.altenkirch@nott.ac.uk}, \email{jakob@von-raumer.de}
\and
   E\"otv\"os Lor\'and University, Budapest, Hungary\\
   \email{\{akaposi, kovacsandras\}@inf.elte.hu}
}

\begin{document}
\maketitle

%\section{Motivation}

Inductive-inductive types ~\cite{nordvallinductive, gabephd}
allow the mutual definition of a type and, for example, a type family indexed
over that type.
This can be used to encode collections of types which are intricately inter-related
such as the syntax of type theory itself~\cite{ttintt}, where we define a type $\Con : \UU$
of contexts at the same time as a type of types over a context: $\Ty : \Con \to \UU$.

Many theorem provers like Coq~\cite{coq} or Lean~\cite{lean}, which
are based on foundations similar to the calculus of constructions (CoC),
do not provide native support for inductive-inductive types.
This raises the question about whether each example of an inductive-inductive
type can be reduced to a (mutual) inductive family, which is supported by these
kinds of system.

In the above example of contexts and types, we can achieve this goal by
first stripping away the type dependencies (``type erasure'') and then defining
a predicate which states whether an instance of the erased types is well-formed
according to the dependencies we erased (cf. last year's talk~\cite{types2018}).
The recursor is obtained by defining a relation between erased types and the
types of an arbitrary algebra, which then can be shown to be functional.
In Lean, the main definitions of such a construction would look like this, with
\texttt{S'0} being the erased types, \texttt{Sw} being the wellformedness predicate,
and \texttt{rel} being the recursor relation:
\noindent
\begin{minipage}{.33\textwidth}
\begin{lstlisting}
inductive S'0 : bool → Type
| nil : S'0 ⊥
| ext : S'0 ⊥ → S'0 ⊤ → S'0 ⊥
| unit : S'0 ⊥ → S'0 ⊤
| pi : S'0 ⊥ → S'0 ⊤
       → S'0 ⊤ → S'0 ⊤
\end{lstlisting}
\end{minipage} \hfill
\begin{minipage}{.65\textwidth}
\begin{lstlisting}
def Sw_arg (b : bool) : Type := if b then unit else S'.C

inductive Sw : Π b, S'0 b → Sw_arg b → Prop
| nil : Sw ⊥ S'0.nil ()
| ext : Π Γ A xΓ, Sw ⊥ Γ xΓ → Sw ⊤ A Γ → Sw ⊥ (S'.ext Γ A) ()
| unit : Π Γ xΓ, Sw ⊥ Γ xΓ → Sw ⊤ (S'.unit Γ) Γ
| pi : Π Γ A B xΓ, Sw ⊥ Γ xΓ → Sw ⊤ A Γ → Sw ⊤ B (S'.ext Γ A)
       → Sw ⊤ (S'.pi Γ A B) Γ
\end{lstlisting}
\end{minipage}
\noindent\begin{minipage}{\textwidth}\begin{lstlisting}
def rel_arg (b : bool) : Type := if b then M.C else Σ γ, M.T γ

inductive rel : Π b, S'0 b → rel_arg b → Prop
| nil : rel ⊥ S'0.nil M.nil
| ext : Π Γ A γ a, rel ⊥ Γ γ → rel ⊤ A ⟨γ, a⟩ → rel ⊥ (S'0.ext Γ A) (M.ext γ a)
| unit : Π Γ γ, rel ⊥ Γ γ → rel ⊤ (S'0.unit Γ) ⟨γ, M.unit γ⟩
| pi : Π Γ A B γ a b, rel ⊥ Γ γ → rel ⊤ A ⟨γ, a⟩ → rel ⊤ B ⟨M.ext γ a, b⟩
        → rel ⊤ (S'0.pi Γ A B) ⟨γ, M.pi γ a b⟩
\end{lstlisting}
\end{minipage}

\noindent \textbf{This raises the question about how to prove that this strategy works for \emph{every
possible inductive-inductive type} instead of specific examples.}

%\section{Contributions}
\newpage

\noindent Dissecting this question, we provide answers for the following follow-up questions:

\begin{description}
\item[What are inductive-inductive types?]
We modify the approach of Kaposi and Kovács~\cite{qiit}
to use the contexts of a domain-specific type theory to generate the signatures
of inductive-inductive types. The syntax differentiates between \emph{sort
constructors} and \emph{point constructors}.
\item[What are inductive families?]
We use a similar approach to specify inductive families:
We define a syntax of \emph{sort contexts} and of \emph{contexts over a sort context}
to capture mutual inductive families which may be parameterized over metatheoretic
types.
\item[What assumptions do we postulate?]
We define notions of \emph{displayed algebras and their sections} over contexts
describing inductive families, such that we can formally denote the prerequesite
of our reduction:
For every such context, there exists an algebra (the constructor) which is initial
in the sense that every displayed algebra over it has a section (the dependent eliminator).
\item[How to define type erasure and welltypedness.]
We define two \emph{syntactical translations}: One for the type erasure and,
depending on an algebra over it, one for the inductively defined wellformedness
predicate, like the one contained in the above code snippet.
\item[How to define the initial algebra.]
Assuming algebras over these transformed contexts, we generate an algebra over
the original inductive-inductive context of which we are confident that we will
be able to show its initiality.
\end{description}

\noindent
%Note that the same goal can be achieved by constructing the initial term model of
%a universal inductive-inductive type, though that strategy does not use or produce
%the erased syntax.
Our work can be seen as a first step towards a proof of \emph{initiality}
for various flavors of type theory the syntax of which is presented in the form
of a quotient inductive-inductive type.
This would require to generalize the above steps to allow for \emph{path constructors}
in the syntax for inductive-inductive types and \emph{quotienting inductive families}.
We have formalized all results in Agda: \url{https://github.com/javra/indind-agda}

\bibliographystyle{plain}
\bibliography{references}

\end{document}






